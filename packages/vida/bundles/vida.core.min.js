var vida;
(() => {
  "use strict";
  var e = {
      826: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Helmet = void 0);
        const r = n(223);
        class o extends r.Component {
          static SSR(e) {
            const t = /(<helmet\b[^>]*>)((.|\n)*?)(<\/helmet>)/gm,
              n = [],
              r = [];
            if (
              null === document || void 0 === document ? void 0 : document.head
            ) {
              let e = document.head.children;
              for (let t = 0; t < e.length; t++)
                -1 === n.indexOf(e[t]) && n.push(e[t]);
            }
            let o;
            for (; null != (o = t.exec(e)); ) {
              const e = o[1],
                t = o[2];
              e.includes('data-placement="head"') && !n.includes(t)
                ? n.push(t)
                : r.includes(t) || r.push(t);
            }
            return { body: e.replace(t, ""), head: n, footer: r };
          }
          mount() {
            var e, t, n, o;
            for (const i of this.props.children) {
              const s = this.props.footer ? document.body : document.head,
                a = i.tagName;
              let c = [];
              c.push(i.innerText);
              for (let n = 0; n < i.attributes.length; n++)
                c.push(
                  null === (e = i.attributes.item(n)) || void 0 === e
                    ? void 0
                    : e.name.toLowerCase(),
                ),
                  c.push(
                    null === (t = i.attributes.item(n)) || void 0 === t
                      ? void 0
                      : t.value.toLowerCase(),
                  );
              if ("HTML" === a || "BODY" === a) {
                const e = document.getElementsByTagName(a)[0];
                for (let t = 1; t < i.attributes.length; t += 2)
                  e.setAttribute(c[t], c[t + 1]);
                return;
              }
              if ("TITLE" === a) {
                const e = document.getElementsByTagName(a);
                if (e.length) e[0].text = i.text;
                else {
                  const e = r.h("title", null, i.innerHTML);
                  s.appendChild(e);
                }
                return;
              }
              let l = !1;
              c = c.sort();
              const d = document.getElementsByTagName(a);
              for (let e = 0; e < d.length; e++) {
                let t = [];
                t.push(d[e].innerText);
                for (let r = 0; r < d[e].attributes.length; r++)
                  t.push(
                    null === (n = d[e].attributes.item(r)) || void 0 === n
                      ? void 0
                      : n.name.toLowerCase(),
                  ),
                    t.push(
                      null === (o = d[e].attributes.item(r)) || void 0 === o
                        ? void 0
                        : o.value.toLowerCase(),
                    );
                (t = t.sort()),
                  c.length > 0 &&
                    t.length > 0 &&
                    JSON.stringify(c) === JSON.stringify(t) &&
                    (l = !0);
              }
              l || r.appendChildren(s, i);
            }
          }
          render() {
            return isSSR
              ? r.h(
                  "helmet",
                  {
                    "data-ssr": !0,
                    "data-placement": this.props.footer ? "footer" : "head",
                  },
                  this.props.children,
                )
              : [];
          }
        }
        t.Helmet = o;
      },
      35: function (e, t, n) {
        var r =
          (this && this.__rest) ||
          function (e, t) {
            var n = {};
            for (var r in e)
              Object.prototype.hasOwnProperty.call(e, r) &&
                t.indexOf(r) < 0 &&
                (n[r] = e[r]);
            if (
              null != e &&
              "function" == typeof Object.getOwnPropertySymbols
            ) {
              var o = 0;
              for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)
                t.indexOf(r[o]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(e, r[o]) &&
                  (n[r[o]] = e[r[o]]);
            }
            return n;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.Img = void 0);
        const o = n(223),
          i = n(930);
        class s extends o.Component {
          constructor(e) {
            super(e);
            const { key: t, src: n } = this.props;
            (this.id =
              i.strToHash(n) + "-" + i.strToHash(JSON.stringify(this.props))),
              t && (this.id += `$key-${t}`),
              this.state || this.setState({ image: "", isLoaded: !1 });
          }
          mount() {
            const e = this.props,
              { lazy: t = !0, placeholder: n, key: i, ref: s, children: a } = e,
              c = r(e, ["lazy", "placeholder", "key", "ref", "children"]);
            t &&
              new IntersectionObserver(
                (e, t) => {
                  for (const n of e)
                    n.isIntersecting &&
                      (t.disconnect(),
                      (this.state.image = o.h("img", Object.assign({}, c))),
                      this.state.image.complete
                        ? ((this.state.isLoaded = !0), this.update())
                        : (this.state.image.onload = () => {
                            (this.state.isLoaded = !0), this.update();
                          }));
                },
                { threshold: [0, 1] },
              ).observe(this.elements[0]);
          }
          render() {
            const e = this.props,
              {
                lazy: t = !0,
                src: n,
                placeholder: i,
                key: s,
                ref: a,
                children: c,
              } = e,
              l = r(e, [
                "lazy",
                "src",
                "placeholder",
                "key",
                "ref",
                "children",
              ]);
            if (!t)
              return (
                (this.state.image = o.h("img", Object.assign({ src: n }, l))),
                this.state.image
              );
            if (this.state.isLoaded) return this.state.image;
            if ("string" == typeof i)
              return o.h("img", Object.assign({ src: i }, l));
            if ("function" == typeof i) return i();
            {
              const e = {
                  backgroundColor: "lightgray",
                  width: "100px",
                  height: "100px",
                },
                { width: t, height: n } = l,
                i = r(l, ["width", "height"]);
              return (
                t && (e.width = t),
                n && (e.height = n),
                o.h("div", Object.assign({ style: e }, i))
              );
            }
          }
        }
        t.Img = s;
      },
      281: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.VidaLink = t.Switch = t.Route = t.Visible = t.Suspense = t.Link = t.Img = t.Helmet = void 0);
        var r = n(826);
        Object.defineProperty(t, "Helmet", {
          enumerable: !0,
          get: function () {
            return r.Helmet;
          },
        });
        var o = n(35);
        Object.defineProperty(t, "Img", {
          enumerable: !0,
          get: function () {
            return o.Img;
          },
        });
        var i = n(570);
        Object.defineProperty(t, "Link", {
          enumerable: !0,
          get: function () {
            return i.Link;
          },
        });
        var s = n(234);
        Object.defineProperty(t, "Suspense", {
          enumerable: !0,
          get: function () {
            return s.Suspense;
          },
        });
        var a = n(45);
        Object.defineProperty(t, "Visible", {
          enumerable: !0,
          get: function () {
            return a.Visible;
          },
        });
        var c = n(515);
        Object.defineProperty(t, "Route", {
          enumerable: !0,
          get: function () {
            return c.Route;
          },
        }),
          Object.defineProperty(t, "Switch", {
            enumerable: !0,
            get: function () {
              return c.Switch;
            },
          }),
          Object.defineProperty(t, "VidaLink", {
            enumerable: !0,
            get: function () {
              return c.Link;
            },
          });
      },
      570: function (e, t, n) {
        var r =
          (this && this.__rest) ||
          function (e, t) {
            var n = {};
            for (var r in e)
              Object.prototype.hasOwnProperty.call(e, r) &&
                t.indexOf(r) < 0 &&
                (n[r] = e[r]);
            if (
              null != e &&
              "function" == typeof Object.getOwnPropertySymbols
            ) {
              var o = 0;
              for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)
                t.indexOf(r[o]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(e, r[o]) &&
                  (n[r[o]] = e[r[o]]);
            }
            return n;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Link = void 0);
        const o = n(223),
          i = n(826);
        class s extends o.Component {
          mount() {
            const { prefetch: e, href: t, delay: n, back: r = !1 } = this.props;
            r &&
              this.elements[0].addEventListener(
                "click",
                function (e) {
                  e.preventDefault(),
                    e.target.href === document.referrer
                      ? window.history.back()
                      : (window.location.href = t);
                }.bind(this),
              ),
              n &&
                this.elements[0].addEventListener(
                  "click",
                  function (e) {
                    e.preventDefault(),
                      setTimeout(() => {
                        window.location.href = t;
                      }, n);
                  }.bind(this),
                ),
              e &&
                ("hover" === e
                  ? this.prefetchOnHover()
                  : "visible" === e
                  ? this.prefetchOnVisible()
                  : this.addPrefetch());
          }
          prefetchOnHover() {
            this.elements[0].addEventListener(
              "mouseover",
              function () {
                this.addPrefetch();
              }.bind(this),
              { once: !0 },
            );
          }
          prefetchOnVisible() {
            new IntersectionObserver(
              (e, t) => {
                for (const n of e)
                  n.isIntersecting && (t.disconnect(), this.addPrefetch());
              },
              { threshold: [0, 1] },
            ).observe(this.elements[0]);
          }
          addPrefetch() {
            let e = !1;
            const t = document.getElementsByTagName("link");
            for (const n of t)
              "prefetch" === n.getAttribute("rel") &&
                n.getAttribute("href") === this.props.href &&
                (e = !0);
            if (!e) {
              const e = o.h("link", {
                rel: "prefetch",
                href: this.props.href,
                as: "document",
              });
              document.head.appendChild(e);
            }
          }
          render() {
            const e = this.props,
              { children: t, prefetch: n, delay: s, back: a = !1, ref: c } = e,
              l = r(e, ["children", "prefetch", "delay", "back", "ref"]),
              d = o.h("a", Object.assign({}, l), ...t);
            if (n && isSSR) {
              const e = o.h("link", {
                  rel: "prefetch",
                  href: this.props.href,
                  as: "document",
                }),
                t = o.h(i.Helmet, null, e);
              return o.h(o.Fragment, null, [t, d]);
            }
            return d;
          }
        }
        t.Link = s;
      },
      515: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Link = t.to = t.Route = t.Switch = void 0);
        const r = n(223),
          o = [];
        function i(e) {
          window.history.pushState({}, "", e);
          for (const e of o) e.forceUpdate();
        }
        function s(e) {
          window.history.replaceState({}, "", e);
          for (const e of o) e.forceUpdate();
        }
        function a(e, t) {
          const { exact: n = !1, regex: r } = t;
          let o,
            { path: i } = t;
          if (!i) return { path: null, url: e, isExact: !0 };
          let s = {};
          if (i.includes("/:")) {
            const t = i.split("/"),
              n = e.split("/");
            t.forEach((e, o) => {
              if (/^:/.test(e)) {
                const i = e.slice(1),
                  a = n[o];
                if (r && r[i] && !r[i].test(a)) return null;
                (s = Object.assign(Object.assign({}, s), { [i]: a })),
                  (t[o] = n[o]);
              }
            }),
              (i = t.join("/"));
          }
          if (
            ("*" === i && (o = [e]), o || (o = new RegExp(`^${i}`).exec(e)), !o)
          )
            return null;
          const a = o[0],
            c = e === a;
          return n && !c ? null : { path: i, url: a, isExact: c, params: s };
        }
        class c extends r.Component {
          constructor() {
            super(...arguments),
              (this.index = 0),
              (this.path = ""),
              (this.match = { index: -1, path: "" });
          }
          mount() {
            window.addEventListener("popstate", this.forceUpdate.bind(this)),
              o.push(this);
          }
          destroy() {
            o.splice(o.indexOf(this), 1),
              window.removeEventListener(
                "popstate",
                this.forceUpdate.bind(this),
              );
          }
          forceUpdate() {
            this.findChild(), this.shouldUpdate() && this.update();
          }
          findChild() {
            this.match = { index: -1, path: "" };
            for (const [e, t] of this.props.children.entries()) {
              const { path: n, exact: r, regex: o } = t.props;
              if (
                a(
                  "undefined" != typeof isSSR
                    ? _nano.location.pathname
                    : window.location.pathname,
                  { path: n, exact: r, regex: o },
                )
              )
                return (this.match.index = e), void (this.match.path = n);
            }
          }
          shouldUpdate() {
            return (
              this.path !== this.match.path || this.index !== this.match.index
            );
          }
          render() {
            this.findChild();
            const e = this.props.children[this.match.index];
            if (e) {
              const { path: t } = e.props;
              (this.path = t), (this.index = this.match.index);
              const n = r.renderElement(e);
              return r.renderElement(n);
            }
            return this.props.fallback
              ? r.renderElement(this.props.fallback)
              : r.h("div", { class: "route" }, "not found");
          }
        }
        (t.Switch = c),
          (t.Route = function ({ path: e, regex: t, children: n }) {
            for (const r of n)
              r.props &&
                (r.props = Object.assign(Object.assign({}, r.props), {
                  route: { path: e, regex: t },
                }));
            return n;
          }),
          (t.to = (e, t = !1) => {
            t ? s(e) : i(e);
          }),
          (t.Link = function ({ to: e, replace: t, children: n }) {
            return r.h(
              "a",
              {
                href: e,
                onClick: function (n) {
                  n.preventDefault(), t ? s(e) : i(e);
                },
              },
              n,
            );
          });
      },
      234: function (e, t, n) {
        var r =
            (this && this.__awaiter) ||
            function (e, t, n, r) {
              return new (n || (n = Promise))(function (o, i) {
                function s(e) {
                  try {
                    c(r.next(e));
                  } catch (e) {
                    i(e);
                  }
                }
                function a(e) {
                  try {
                    c(r.throw(e));
                  } catch (e) {
                    i(e);
                  }
                }
                function c(e) {
                  var t;
                  e.done
                    ? o(e.value)
                    : ((t = e.value),
                      t instanceof n
                        ? t
                        : new n(function (e) {
                            e(t);
                          })).then(s, a);
                }
                c((r = r.apply(e, t || [])).next());
              });
            },
          o =
            (this && this.__rest) ||
            function (e, t) {
              var n = {};
              for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) &&
                  t.indexOf(r) < 0 &&
                  (n[r] = e[r]);
              if (
                null != e &&
                "function" == typeof Object.getOwnPropertySymbols
              ) {
                var o = 0;
                for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)
                  t.indexOf(r[o]) < 0 &&
                    Object.prototype.propertyIsEnumerable.call(e, r[o]) &&
                    (n[r[o]] = e[r[o]]);
              }
              return n;
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Suspense = void 0);
        const i = n(223),
          s = n(930);
        class a extends i.Component {
          constructor(e) {
            super(e), (this.isReady = !1);
            const t = this.props,
              { fallback: n, cache: r = !1, children: i } = t,
              a = o(t, ["fallback", "cache", "children"]);
            this.id = s.strToHash(
              JSON.stringify(a, function (e, t) {
                return "function" == typeof t ? `${t}` : t;
              }),
            );
          }
          mount() {
            return r(this, void 0, void 0, function* () {
              const e = this.props,
                { fallback: t, cache: n = !1, children: r } = e,
                i = o(e, ["fallback", "cache", "children"]);
              if ((n && (this.initialState = {}), this.loadFromCache(n)))
                return;
              const s = Object.values(i).map((e) => e()),
                a = yield Promise.all(s),
                c = this.prepareData(i, a, n);
              this.addDataToChildren(c), (this.isReady = !0), this.update();
            });
          }
          loadFromCache(e) {
            const t = this.state && e && Object.keys(this.state).length;
            return (
              e && (this.addDataToChildren(this.state), (this.isReady = !0)), t
            );
          }
          ssr() {
            const e = this.props,
              { fallback: t, cache: n = !1, children: r } = e,
              i = o(e, ["fallback", "cache", "children"]),
              s = Object.values(i).map((e) => e()),
              a = this.prepareData(i, s, !1);
            this.addDataToChildren(a);
          }
          addDataToChildren(e) {
            for (const t of this.props.children)
              t.props &&
                (t.props = Object.assign(Object.assign({}, t.props), e));
          }
          prepareData(e, t, n) {
            return Object.keys(e).reduce(
              (e, r, o) => (
                n &&
                  (this.state = Object.assign(Object.assign({}, this.state), {
                    [r]: t[o],
                  })),
                Object.assign(Object.assign({}, e), { [r]: t[o] })
              ),
              {},
            );
          }
          render() {
            if ("undefined" == typeof isSSR) {
              const { cache: e = !1 } = this.props;
              return (
                this.loadFromCache(e),
                this.isReady ? this.props.children : this.props.fallback
              );
            }
            return this.ssr(), this.props.children;
          }
        }
        t.Suspense = a;
      },
      45: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Visible = void 0);
        const r = n(223);
        class o extends r.Component {
          constructor() {
            super(...arguments), (this.isVisible = !1);
          }
          mount() {
            new IntersectionObserver(
              (e, t) => {
                for (const n of e)
                  n.isIntersecting &&
                    (t.disconnect(), (this.isVisible = !0), this.update());
              },
              { threshold: [0, 1] },
            ).observe(this.elements[0]);
          }
          render() {
            return this.isVisible
              ? (this.props.onVisible && this.props.onVisible(),
                r.render(this.props.component || this.props.children[0]))
              : r.h("div", { "data-visible": !1, visibility: "hidden" });
          }
        }
        t.Visible = o;
      },
      547: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.appendChildren = void 0);
        const r = n(223);
        t.appendChildren = function e(t, n) {
          if (Array.isArray(n)) {
            "object" == typeof n && (n = Array.from(n));
            for (const o of n)
              if (Array.isArray(o)) e(t, o);
              else {
                let n = r.renderElement(o);
                n &&
                  (Array.isArray(n)
                    ? e(t, n)
                    : t.appendChild(
                        (null == n ? void 0 : n.nodeType)
                          ? n
                          : document.createTextNode("" + n),
                      ));
              }
          } else e(t, [n]);
        };
      },
      844: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Component = void 0);
        const r = n(930),
          o = n(223);
        t.Component = class {
          constructor(e) {
            (this.props = e),
              (this._elements = []),
              (this.id = this._getHash());
          }
          render(e) {}
          mount() {}
          beforeMount() {}
          destroy() {}
          _getHash() {}
          setState(e, t = !1) {
            (this.state =
              e && "object" == typeof e
                ? Object.assign(Object.assign({}, this.state), e)
                : e),
              t && this.update();
          }
          get state() {
            return o._state.get(this.id);
          }
          set state(e) {
            o._state.set(this.id, e);
          }
          set initialState(e) {
            this.state || (this.state = e);
          }
          get elements() {
            return this._elements;
          }
          set elements(e) {
            Array.isArray(e) || (e = [e]);
            for (const t of e) this._elements.push(t);
          }
          addNodeRemoveListener() {
            /^[^{]+{\s+}$/gm.test(this.destroy.toString()) ||
              r.onNodeRemove(this.elements[0], () => {
                this._skipUnmout || this.destroy();
              });
          }
          _mount() {
            this.addNodeRemoveListener(), this.mount();
          }
          _destory() {
            this._hasUnmounted || (this.destroy(), (this._hasUnmounted = !0));
          }
          update(e) {
            this._skipUnmout = !0;
            const t = [...this.elements];
            this._elements = [];
            let n = this.render(e);
            (n = o.renderElement(n)), (this.elements = n);
            const i = t[0].parentElement;
            i ||
              console.warn("Component needs a parent element to get updated!");
            for (const e of this.elements) i.insertBefore(e, t[0]);
            for (let e of t) e.remove(), (e = null);
            this.addNodeRemoveListener(),
              r.nextTick(() => {
                (this._skipUnmout = !1),
                  this.elements[0].isConnected || this._destory();
              });
          }
        };
      },
      55: (e, t) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createContext = void 0),
          (t.createContext = function (e) {
            let t = e;
            return {
              Provider(e) {
                if (e.value) return (t = e.value), e.children;
              },
              Consumer: (e) => ({
                component: e.children[0](t),
                props: Object.assign(Object.assign({}, e), { context: t }),
              }),
              get: () => t,
              set(e) {
                t = e;
              },
            };
          });
      },
      742: (e, t) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Fragment = void 0),
          (t.Fragment = (e) => e.children);
      },
      58: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.h = void 0);
        const r = n(930),
          o = n(223);
        t.h = function (e, t, ...n) {
          if ("string" != typeof e)
            return {
              component: e,
              props: Object.assign(Object.assign({}, t), { children: n }),
            };
          let i;
          const s = "svg" === e ? o.hNS("svg") : document.createElement(e);
          for (const e in t) {
            if ("style" === e && "object" == typeof t[e]) {
              const n = Object.keys(t[e])
                .map((n) => `${n}:${t[e][n]}`)
                .join(";")
                .replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);
              t[e] = n + ";";
            }
            "ref" === e && (i = t[e]),
              r.isEvent(s, e.toLowerCase())
                ? s.addEventListener(e.toLowerCase().substring(2), (n) =>
                    t[e](n),
                  )
                : s.setAttribute(e, t[e]);
          }
          return o.appendChildren(s, n), i && i(s), s.ssr ? s.ssr : s;
        };
      },
      75: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hydrate = void 0);
        const r = n(223);
        t.hydrate = function (e, t = null, n = !0) {
          return r.render(e, t, n);
        };
      },
      223: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.withStyles = t.lazyHydration = t._clearState = t._state = t.createContext = t.Fragment = t.Component = t.hydrate = t.hNS = t.renderElement = t.render = t.h = t.appendChildren = void 0);
        var r = n(547);
        Object.defineProperty(t, "appendChildren", {
          enumerable: !0,
          get: function () {
            return r.appendChildren;
          },
        });
        var o = n(58);
        Object.defineProperty(t, "h", {
          enumerable: !0,
          get: function () {
            return o.h;
          },
        });
        var i = n(455);
        Object.defineProperty(t, "render", {
          enumerable: !0,
          get: function () {
            return i.render;
          },
        });
        var s = n(255);
        Object.defineProperty(t, "renderElement", {
          enumerable: !0,
          get: function () {
            return s.renderElement;
          },
        }),
          Object.defineProperty(t, "hNS", {
            enumerable: !0,
            get: function () {
              return s.hNS;
            },
          });
        var a = n(75);
        Object.defineProperty(t, "hydrate", {
          enumerable: !0,
          get: function () {
            return a.hydrate;
          },
        });
        var c = n(844);
        Object.defineProperty(t, "Component", {
          enumerable: !0,
          get: function () {
            return c.Component;
          },
        });
        var l = n(742);
        Object.defineProperty(t, "Fragment", {
          enumerable: !0,
          get: function () {
            return l.Fragment;
          },
        });
        var d = n(55);
        Object.defineProperty(t, "createContext", {
          enumerable: !0,
          get: function () {
            return d.createContext;
          },
        });
        var h = n(83);
        Object.defineProperty(t, "_state", {
          enumerable: !0,
          get: function () {
            return h._state;
          },
        }),
          Object.defineProperty(t, "_clearState", {
            enumerable: !0,
            get: function () {
              return h._clearState;
            },
          });
        var u = n(228);
        Object.defineProperty(t, "lazyHydration", {
          enumerable: !0,
          get: function () {
            return u.lazyHydration;
          },
        });
        var p = n(786);
        Object.defineProperty(t, "withStyles", {
          enumerable: !0,
          get: function () {
            return p.withStyles;
          },
        });
      },
      228: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.lazyHydration = void 0);
        const r = n(281),
          o = n(223);
        t.lazyHydration = function (e, t, n = !0) {
          const i = o.h(r.Visible, null, e);
          return o.hydrate(i, t, n);
        };
      },
      455: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.removeAllChildNodes = t.render = void 0);
        const r = n(223);
        function o(e) {
          for (; e.firstChild; ) e.removeChild(e.firstChild);
        }
        (t.render = function (e, t = null, n = !0) {
          let i = r.renderElement(e);
          return (
            Array.isArray(i) &&
              ((i = i.map((e) => r.renderElement(e))),
              1 === i.length && (i = i[0])),
            t
              ? (n && o(t),
                i && t.id && t.id === i.id && t.parentElement
                  ? void t.parentElement.replaceChild(i, t)
                  : (Array.isArray(i)
                      ? i.map((e) => r.appendChildren(t, r.renderElement(e)))
                      : r.appendChildren(t, r.renderElement(i)),
                    t.ssr ? t.ssr : t))
              : "boolean" == typeof isSSR && isSSR && !Array.isArray(i)
              ? [i]
              : i
          );
        }),
          (t.removeAllChildNodes = o);
      },
      255: (e, t, n) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hNS = t.renderElement = void 0);
        const r = n(930);
        function o(e) {
          return document.createElementNS("http://www.w3.org/2000/svg", e);
        }
        (t.renderElement = function e(t) {
          var n;
          return ["undefined"].includes(typeof t) || null == t
            ? []
            : "string" == typeof t
            ? t
            : "number" == typeof t
            ? "" + t
            : (null == t ? void 0 : t.tagName) &&
              "svg" === t.tagName.toLowerCase()
            ? (function (e) {
                const t = e.children[0],
                  n = t.attributes,
                  r = o("svg");
                for (const e of n) r.setAttribute(e.name, e.value);
                return (r.innerHTML = t.innerHTML), r;
              })({ children: [t] })
            : (null == t ? void 0 : t.tagName)
            ? t
            : t &&
              t.component &&
              t.component.prototype &&
              t.component.prototype.constructor &&
              /^class\s/.test(Function.prototype.toString.call(t.component))
            ? (function (t) {
                const { component: n, props: o } = t,
                  i = r.strToHash(n.toString());
                n.prototype._getHash = () => i;
                const s = new n(o);
                s.beforeMount();
                let a = s.render();
                return (
                  (a = e(a)),
                  (s.elements = a),
                  (null == o ? void 0 : o.ref) && o.ref(s),
                  "undefined" == typeof isSSR &&
                    r.nextTick(() => {
                      s._mount();
                    }),
                  a
                );
              })(t)
            : t.component && "function" == typeof t.component
            ? (function (t) {
                const { component: n, props: r } = t;
                return e(n(r));
              })(t)
            : Array.isArray(t)
            ? t.map((t) => e(t)).flat()
            : "function" == typeof t
            ? e(t())
            : ((null === (n = null == t ? void 0 : t.component) || void 0 === n
                ? void 0
                : n.tagName) &&
                "string" == typeof t.component.tagName) ||
              Array.isArray(t.component) ||
              t.component
            ? e(t.component)
            : void 0;
        }),
          (t.hNS = o);
      },
      83: (e, t) => {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t._clearState = t._state = void 0),
          (t._state = new Map()),
          (t._clearState = function () {
            t._state.clear();
          });
      },
      786: function (e, t, n) {
        var r =
          (this && this.__rest) ||
          function (e, t) {
            var n = {};
            for (var r in e)
              Object.prototype.hasOwnProperty.call(e, r) &&
                t.indexOf(r) < 0 &&
                (n[r] = e[r]);
            if (
              null != e &&
              "function" == typeof Object.getOwnPropertySymbols
            ) {
              var o = 0;
              for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)
                t.indexOf(r[o]) < 0 &&
                  Object.prototype.propertyIsEnumerable.call(e, r[o]) &&
                  (n[r[o]] = e[r[o]]);
            }
            return n;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.withStyles = void 0);
        const o = n(281),
          i = n(223);
        t.withStyles = function (e) {
          return function (t) {
            return class extends i.Component {
              render() {
                const n = this.props,
                  { children: s } = n,
                  a = r(n, ["children"]),
                  c = i.h(o.Helmet, null, i.h("style", null, e.toString())),
                  l = s.length
                    ? i.h(t, Object.assign({}, a), s)
                    : i.h(t, Object.assign({}, this.props));
                return i.h(i.Fragment, null, c, l);
              }
            };
          };
        };
      },
      930: (e, t) => {
        function n(e, t) {
          return e && (e === t || n(e.parentNode, t));
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.nodeToString = t.task = t.onNodeRemove = t.isDescendant = t.strToHash = t.detectSSR = t.isEvent = t.nextTick = void 0),
          (t.nextTick =
            "function" == typeof Promise
              ? Promise.prototype.then.bind(Promise.resolve())
              : setTimeout),
          (t.isEvent = function (e, t) {
            return (
              !!~t.indexOf("on") &&
              (!!e.ssr || ["function", "object"].includes(typeof e[t]))
            );
          }),
          (t.detectSSR = function () {
            return "undefined" != typeof Deno || "undefined" == typeof window;
          }),
          (t.strToHash = function (e) {
            let t = 0;
            if (!e.length) return t;
            for (let n = 0; n < e.length; n++)
              (t = (t << 5) - t + e.charCodeAt(n)), (t |= 0);
            return Math.abs(t).toString(32);
          }),
          (t.isDescendant = n),
          (t.onNodeRemove = function (e, t) {
            let r = new MutationObserver((o) => {
              for (const i of o)
                i.removedNodes.forEach((o) => {
                  n(e, o) && (t(), r && (r.disconnect(), (r = void 0)));
                });
            });
            return r.observe(document, { childList: !0, subtree: !0 }), r;
          }),
          (t.task = function (e) {
            return setTimeout(e, 0);
          }),
          (t.nodeToString = function (e) {
            const t = document.createDocumentFragment();
            return t.appendChild(e.cloneNode(!0)), t.toString();
          });
      },
    },
    t = {};
  function n(r) {
    var o = t[r];
    if (void 0 !== o) return o.exports;
    var i = (t[r] = { exports: {} });
    return e[r].call(i.exports, i, i.exports, n), i.exports;
  }
  var r = {};
  (() => {
    var e = r;
    const t = n(223);
    e.default = { h: t.h, render: t.render };
  })(),
    (vida = r.default);
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRhLy4vc3JjL2NvbXBvbmVudHMvaGVsbWV0LnRzIiwid2VicGFjazovL3ZpZGEvLi9zcmMvY29tcG9uZW50cy9pbWcudHMiLCJ3ZWJwYWNrOi8vdmlkYS8uL3NyYy9jb21wb25lbnRzL2luZGV4LnRzIiwid2VicGFjazovL3ZpZGEvLi9zcmMvY29tcG9uZW50cy9saW5rLnRzIiwid2VicGFjazovL3ZpZGEvLi9zcmMvY29tcG9uZW50cy9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vdmlkYS8uL3NyYy9jb21wb25lbnRzL3N1c3BlbnNlLnRzIiwid2VicGFjazovL3ZpZGEvLi9zcmMvY29tcG9uZW50cy92aXNpYmxlLnRzIiwid2VicGFjazovL3ZpZGEvLi9zcmMvY29yZS9hcHBlbmRDaGlsZHJlbi50cyIsIndlYnBhY2s6Ly92aWRhLy4vc3JjL2NvcmUvY29tcG9uZW50LnRzIiwid2VicGFjazovL3ZpZGEvLi9zcmMvY29yZS9jb250ZXh0LnRzIiwid2VicGFjazovL3ZpZGEvLi9zcmMvY29yZS9mcmFnbWVudC50cyIsIndlYnBhY2s6Ly92aWRhLy4vc3JjL2NvcmUvaC50cyIsIndlYnBhY2s6Ly92aWRhLy4vc3JjL2NvcmUvaHlkcmF0ZS50cyIsIndlYnBhY2s6Ly92aWRhLy4vc3JjL2NvcmUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdmlkYS8uL3NyYy9jb3JlL2xhenlIeWRyYXRpb24udHMiLCJ3ZWJwYWNrOi8vdmlkYS8uL3NyYy9jb3JlL3JlbmRlci50cyIsIndlYnBhY2s6Ly92aWRhLy4vc3JjL2NvcmUvcmVuZGVyRWxlbWVudC50cyIsIndlYnBhY2s6Ly92aWRhLy4vc3JjL2NvcmUvc3RhdGUudHMiLCJ3ZWJwYWNrOi8vdmlkYS8uL3NyYy9jb3JlL3dpdGhTdHlsZXMudHMiLCJ3ZWJwYWNrOi8vdmlkYS8uL3NyYy91dGlscy50cyIsIndlYnBhY2s6Ly92aWRhL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3ZpZGEvLi9zcmMvYnVuZGxlcy9jb3JlLnRzIl0sIm5hbWVzIjpbIkhlbG1ldCIsIkNvbXBvbmVudCIsImJvZHkiLCJyZWciLCJoZWFkIiwiZm9vdGVyIiwiZG9jdW1lbnQiLCJjaGlsZHJlbiIsImkiLCJsZW5ndGgiLCJpbmRleE9mIiwicHVzaCIsInJlc3VsdCIsImV4ZWMiLCJmaXJzdCIsInNlY29uZCIsImluY2x1ZGVzIiwicmVwbGFjZSIsImVsZW1lbnQiLCJ0aGlzIiwicHJvcHMiLCJwYXJlbnQiLCJ0YWciLCJ0YWdOYW1lIiwiYXR0cnMiLCJpbm5lclRleHQiLCJhdHRyaWJ1dGVzIiwiaXRlbSIsIm5hbWUiLCJ0b0xvd2VyQ2FzZSIsInZhbHVlIiwiaHRtbFRhZyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic2V0QXR0cmlidXRlIiwidGl0bGVUYWciLCJ0ZXh0IiwiaCIsImlubmVySFRNTCIsImFwcGVuZENoaWxkIiwiZXhpc3RzIiwic29ydCIsImVsIiwiYXR0cnMyIiwiaiIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcHBlbmRDaGlsZHJlbiIsImlzU1NSIiwiSW1nIiwic3VwZXIiLCJrZXkiLCJzcmMiLCJpZCIsInN0clRvSGFzaCIsInN0YXRlIiwic2V0U3RhdGUiLCJpbWFnZSIsImlzTG9hZGVkIiwibGF6eSIsInBsYWNlaG9sZGVyIiwicmVmIiwicmVzdCIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cmllcyIsIm9ic2VydmVyIiwiZW50cnkiLCJpc0ludGVyc2VjdGluZyIsImRpc2Nvbm5lY3QiLCJjb21wbGV0ZSIsInVwZGF0ZSIsIm9ubG9hZCIsInRocmVzaG9sZCIsIm9ic2VydmUiLCJlbGVtZW50cyIsInN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwid2lkdGgiLCJoZWlnaHQiLCJvdGhlcnMiLCJMaW5rIiwiU3VzcGVuc2UiLCJWaXNpYmxlIiwiUm91dGUiLCJTd2l0Y2giLCJwcmVmZXRjaCIsImhyZWYiLCJkZWxheSIsImJhY2siLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInByZXZlbnREZWZhdWx0IiwidGFyZ2V0IiwicmVmZXJyZXIiLCJ3aW5kb3ciLCJoaXN0b3J5IiwibG9jYXRpb24iLCJiaW5kIiwic2V0VGltZW91dCIsInByZWZldGNoT25Ib3ZlciIsInByZWZldGNoT25WaXNpYmxlIiwiYWRkUHJlZmV0Y2giLCJvbmNlIiwibGlua3MiLCJsaW5rIiwiZ2V0QXR0cmlidXRlIiwicmVsIiwiYXMiLCJhIiwiaGVsbWV0IiwiRnJhZ21lbnQiLCJpbnN0YW5jZXMiLCJoaXN0b3J5UHVzaCIsInBhdGgiLCJwdXNoU3RhdGUiLCJpbnN0YW5jZSIsImZvcmNlVXBkYXRlIiwiaGlzdG9yeVJlcGxhY2UiLCJyZXBsYWNlU3RhdGUiLCJtYXRjaFBhdGgiLCJwYXRobmFtZSIsIm9wdGlvbnMiLCJleGFjdCIsInJlZ2V4IiwibWF0Y2giLCJ1cmwiLCJpc0V4YWN0IiwicGFyYW1zIiwicGF0aEFyciIsInNwbGl0IiwicGF0aG5hbWVBcnIiLCJmb3JFYWNoIiwicCIsInRlc3QiLCJzbGljZSIsImpvaW4iLCJSZWdFeHAiLCJpbmRleCIsInNwbGljZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmaW5kQ2hpbGQiLCJzaG91bGRVcGRhdGUiLCJjaGlsZCIsIl9uYW5vIiwicmVuZGVyRWxlbWVudCIsImZhbGxiYWNrIiwiY2xhc3MiLCJyb3V0ZSIsInRvIiwib25DbGljayIsImV2ZW50IiwiaXNSZWFkeSIsImNhY2hlIiwiX2tleSIsInZhbCIsImluaXRpYWxTdGF0ZSIsImxvYWRGcm9tQ2FjaGUiLCJwcm9taXNlcyIsIk9iamVjdCIsInZhbHVlcyIsIm1hcCIsInJlc29sdmVkIiwiUHJvbWlzZSIsImFsbCIsImRhdGEiLCJwcmVwYXJlRGF0YSIsImFkZERhdGFUb0NoaWxkcmVuIiwiY2FjaGVkIiwia2V5cyIsImZ1bmNzIiwiZnVuYyIsInJlZHVjZSIsImFjYyIsInNzciIsImlzVmlzaWJsZSIsIm9uVmlzaWJsZSIsInJlbmRlciIsImNvbXBvbmVudCIsInZpc2liaWxpdHkiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tIiwiY29tcCIsIm5vZGVUeXBlIiwiY3JlYXRlVGV4dE5vZGUiLCJfZWxlbWVudHMiLCJfZ2V0SGFzaCIsIl91cGRhdGUiLCJfc3RhdGUiLCJnZXQiLCJzZXQiLCJkZXN0cm95IiwidG9TdHJpbmciLCJvbk5vZGVSZW1vdmUiLCJfc2tpcFVubW91dCIsImFkZE5vZGVSZW1vdmVMaXN0ZW5lciIsIm1vdW50IiwiX2hhc1VubW91bnRlZCIsIm9sZEVsZW1lbnRzIiwicGFyZW50RWxlbWVudCIsImNvbnNvbGUiLCJ3YXJuIiwiaW5zZXJ0QmVmb3JlIiwicmVtb3ZlIiwibmV4dFRpY2siLCJpc0Nvbm5lY3RlZCIsIl9kZXN0b3J5IiwiY3R4IiwiX2N0eCIsIkNvbnN1bWVyIiwiY29udGV4dCIsImhOUyIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZXMiLCJrIiwiaXNFdmVudCIsInN1YnN0cmluZyIsInJlbW92ZUNoaWxkTm9kZXMiLCJoeWRyYXRlIiwiY3JlYXRlQ29udGV4dCIsIl9jbGVhclN0YXRlIiwibGF6eUh5ZHJhdGlvbiIsIndpdGhTdHlsZXMiLCJjbXAiLCJyZW1vdmVBbGxDaGlsZE5vZGVzIiwiZmlyc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwiYyIsInJlcGxhY2VDaGlsZCIsImNyZWF0ZUVsZW1lbnROUyIsInN2ZyIsImF0dHIiLCJTVkciLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsIkZ1bmN0aW9uIiwiY2FsbCIsImhhc2giLCJiZWZvcmVNb3VudCIsIl9tb3VudCIsInJlbmRlckNsYXNzQ29tcG9uZW50IiwicmVuZGVyRnVuY3Rpb25hbENvbXBvbmVudCIsImZsYXQiLCJNYXAiLCJjbGVhciIsIldyYXBwZWRDb21wb25lbnQiLCJpc0Rlc2NlbmRhbnQiLCJkZXNjZW5kYW50Iiwicm9vdCIsInBhcmVudE5vZGUiLCJ0aGVuIiwicmVzb2x2ZSIsInByb3AiLCJEZW5vIiwic3RyIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJhYnMiLCJjYWxsYmFjayIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRMaXN0IiwibXV0IiwicmVtb3ZlZE5vZGVzIiwicmVtb3ZlZE5vZGUiLCJ1bmRlZmluZWQiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwibm9kZSIsInRlbXAiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiY2xvbmVOb2RlIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiZXhwb3J0cyIsIm1vZHVsZSIsIl9fd2VicGFja19tb2R1bGVzX18iXSwibWFwcGluZ3MiOiJrSEFBQSxlQUVBLE1BQWFBLFVBQWUsRUFBQUMsVUFDMUIsV0FBV0MsR0FDVCxNQUFNQyxFQUFNLDRDQUVOQyxFQUFpQixHQUNqQkMsRUFBbUIsR0FFekIsR0FBWSxPQUFSQyxlQUFRLElBQVJBLGNBQVEsRUFBUkEsU0FBVUYsS0FBTSxDQUNsQixJQUFJRyxFQUFZRCxTQUFTRixLQUFLRyxTQUU5QixJQUFLLElBQUlDLEVBQUksRUFBR0EsRUFBSUQsRUFBU0UsT0FBUUQsS0FDQSxJQUEvQkosRUFBS00sUUFBUUgsRUFBU0MsS0FDeEJKLEVBQUtPLEtBQUtKLEVBQVNDLElBS3pCLElBQUlJLEVBRUosS0FBb0MsT0FBNUJBLEVBQVNULEVBQUlVLEtBQUtYLEtBQWdCLENBQ3hDLE1BQU1ZLEVBQVFGLEVBQU8sR0FDZkcsRUFBU0gsRUFBTyxHQUVQRSxFQUFNRSxTQUFTLDJCQUVmWixFQUFLWSxTQUFTRCxHQUFTWCxFQUFLTyxLQUFLSSxHQUN0Q1YsRUFBT1csU0FBU0QsSUFBU1YsRUFBT00sS0FBS0ksR0FJakQsTUFBTyxDQUNMYixLQUZnQkEsRUFBS2UsUUFBUWQsRUFBSyxJQUdsQ0MsT0FDQUMsVUFJSixRLFlBQ0UsSUFBSyxNQUFNYSxLQUFXQyxLQUFLQyxNQUFNYixTQUFVLENBQ3pDLE1BQU1jLEVBQVNGLEtBQUtDLE1BQU1mLE9BQVNDLFNBQVNKLEtBQU9JLFNBQVNGLEtBQ3REa0IsRUFBT0osRUFBd0JLLFFBQ3JDLElBQUlDLEVBQWtCLEdB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ekJGLEVBQUs1RSxjQ2pFVitFLEVBQTJCLEdBRy9CLFNBQVNDLEVBQW9CQyxHQUU1QixJQUFJQyxFQUFlSCxFQUF5QkUsR0FDNUMsUUFBcUJULElBQWpCVSxFQUNILE9BQU9BLEVBQWFDLFFBR3JCLElBQUlDLEVBQVNMLEVBQXlCRSxHQUFZLENBR2pERSxRQUFTLElBT1YsT0FIQUUsRUFBb0JKLEdBQVVyQyxLQUFLd0MsRUFBT0QsUUFBU0MsRUFBUUEsRUFBT0QsUUFBU0gsR0FHcEVJLEVBQU9ELFEsdUJDckJmLGVBRUEsVUFBZSxDQUNiOU8sRUFBQSxFQUFBQSxFQUNBMkksT0FBQSxFQUFBQSxTIiwiZmlsZSI6InZpZGEuY29yZS5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHBlbmRDaGlsZHJlbiwgQ29tcG9uZW50LCBoIH0gZnJvbSBcIi4uL2NvcmVcIjtcblxuZXhwb3J0IGNsYXNzIEhlbG1ldCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBTU1IoYm9keTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVnID0gLyg8aGVsbWV0XFxiW14+XSo+KSgoLnxcXG4pKj8pKDxcXC9oZWxtZXQ+KS9nbTtcblxuICAgIGNvbnN0IGhlYWQ6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgZm9vdGVyOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKGRvY3VtZW50Py5oZWFkKSB7XG4gICAgICBsZXQgY2hpbGRyZW4gPSAoZG9jdW1lbnQuaGVhZC5jaGlsZHJlbiBhcyB1bmtub3duKSBhcyBzdHJpbmdbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGVhZC5pbmRleE9mKGNoaWxkcmVuW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICBoZWFkLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdDtcblxuICAgIHdoaWxlICgocmVzdWx0ID0gcmVnLmV4ZWMoYm9keSkpICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gcmVzdWx0WzFdO1xuICAgICAgY29uc3Qgc2Vjb25kID0gcmVzdWx0WzJdO1xuXG4gICAgICBjb25zdCB0b0hlYWQgPSBmaXJzdC5pbmNsdWRlcygnZGF0YS1wbGFjZW1lbnQ9XCJoZWFkXCInKTtcblxuICAgICAgaWYgKHRvSGVhZCAmJiAhaGVhZC5pbmNsdWRlcyhzZWNvbmQpKSBoZWFkLnB1c2goc2Vjb25kKTtcbiAgICAgIGVsc2UgaWYgKCFmb290ZXIuaW5jbHVkZXMoc2Vjb25kKSkgZm9vdGVyLnB1c2goc2Vjb25kKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbGVhbkJvZHkgPSBib2R5LnJlcGxhY2UocmVnLCBcIlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgYm9keTogY2xlYW5Cb2R5LFxuICAgICAgaGVhZCxcbiAgICAgIGZvb3RlcixcbiAgICB9O1xuICB9XG5cbiAgbW91bnQoKSB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucHJvcHMuZm9vdGVyID8gZG9jdW1lbnQuYm9keSA6IGRvY3VtZW50LmhlYWQ7XG4gICAgICBjb25zdCB0YWcgPSAoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkudGFnTmFtZTtcbiAgICAgIGxldCBhdHRyczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgYXR0cnMucHVzaChlbGVtZW50LmlubmVyVGV4dCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF0dHJzLnB1c2goZWxlbWVudC5hdHRyaWJ1dGVzLml0ZW0oaSk/Lm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGF0dHJzLnB1c2goZWxlbWVudC5hdHRyaWJ1dGVzLml0ZW0oaSk/LnZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFnID09PSBcIkhUTUxcIiB8fCB0YWcgPT09IFwiQk9EWVwiKSB7XG4gICAgICAgIGNvbnN0IGh0bWxUYWcgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGh0bWxUYWcuc2V0QXR0cmlidXRlKGF0dHJzW2ldLCBhdHRyc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBcIlRJVExFXCIpIHtcbiAgICAgICAgY29uc3QgdGl0bGVUYWcgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcbiAgICAgICAgICB0YWcsXG4gICAgICAgICkgYXMgSFRNTENvbGxlY3Rpb25PZjxIVE1MVGl0bGVFbGVtZW50PjtcblxuICAgICAgICBpZiAodGl0bGVUYWcubGVuZ3RoKSB7XG4gICAgICAgICAgdGl0bGVUYWdbMF0udGV4dCA9IGVsZW1lbnQudGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0aXRsZVRhZyA9IGgoXG4gICAgICAgICAgICBcInRpdGxlXCIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwsXG4gICAgICAgICAgKSBhcyBIVE1MVGl0bGVFbGVtZW50O1xuICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aXRsZVRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXhpc3RzID0gZmFsc2U7XG4gICAgICBhdHRycyA9IGF0dHJzLnNvcnQoKTtcblxuICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcbiAgICAgICAgdGFnLFxuICAgICAgKSBhcyBIVE1MQ29sbGVjdGlvbk9mPEhUTUxFbGVtZW50PjtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXR0cnMyOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIGF0dHJzMi5wdXNoKGVsW2ldLmlubmVyVGV4dCk7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBlbFtpXS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgYXR0cnMyLnB1c2goZWxbaV0uYXR0cmlidXRlcy5pdGVtKGopPy5uYW1lLnRvTG93ZXJDYXNlKCkgYXMgc3RyaW5nKTtcbiAgICAgICAgICBhdHRyczIucHVzaChlbFtpXS5hdHRyaWJ1dGVzLml0ZW0oaik/LnZhbHVlLnRvTG93ZXJDYXNlKCkgYXMgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyczIgPSBhdHRyczIuc29ydCgpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBhdHRycy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgYXR0cnMyLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShhdHRycykgPT09IEpTT04uc3RyaW5naWZ5KGF0dHJzMilcbiAgICAgICAgKVxuICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgIGFwcGVuZENoaWxkcmVuKHBhcmVudCwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmIChpc1NTUikge1xuICAgICAgcmV0dXJuIGgoXG4gICAgICAgIFwiaGVsbWV0XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBcImRhdGEtc3NyXCI6IHRydWUsXG4gICAgICAgICAgXCJkYXRhLXBsYWNlbWVudFwiOiB0aGlzLnByb3BzLmZvb3RlciA/IFwiZm9vdGVyXCIgOiBcImhlYWRcIixcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbixcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgaCB9IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBzdHJUb0hhc2ggfSBmcm9tIFwiLi4vdXRpbHNcIjtcblxuZXhwb3J0IGNsYXNzIEltZyBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBhbnkpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICBjb25zdCB7IGtleSwgc3JjIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuaWQgPSBzdHJUb0hhc2goc3JjKSArIFwiLVwiICsgc3RyVG9IYXNoKEpTT04uc3RyaW5naWZ5KHRoaXMucHJvcHMpKTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICB0aGlzLmlkICs9IGAka2V5LSR7a2V5fWA7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXRlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgaW1hZ2U6IFwiXCIsIGlzTG9hZGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cblxuICBtb3VudCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYXp5ID0gdHJ1ZSxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAga2V5LFxuICAgICAgcmVmLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIWxhenkpIHJldHVybjtcblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbWFnZSA9IGgoXCJpbWdcIiwgeyAuLi5yZXN0IH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLmltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgdGhyZXNob2xkOiBbMCwgMV0gfSxcbiAgICApO1xuXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnRzWzBdKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYXp5ID0gdHJ1ZSxcbiAgICAgIHNyYyxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAga2V5LFxuICAgICAgcmVmLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIWxhenkpIHtcbiAgICAgIHRoaXMuc3RhdGUuaW1hZ2UgPSBoKFwiaW1nXCIsIHsgc3JjLCAuLi5yZXN0IH0pO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaW1hZ2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUuaXNMb2FkZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmltYWdlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsYWNlaG9sZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gaChcImltZ1wiLCB7IHNyYzogcGxhY2Vob2xkZXIsIC4uLnJlc3QgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGxhY2Vob2xkZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwibGlnaHRncmF5XCIsXG4gICAgICAgIHdpZHRoOiBcIjEwMHB4XCIsXG4gICAgICAgIGhlaWdodDogXCIxMDBweFwiLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCAuLi5vdGhlcnMgfSA9IHJlc3Q7XG4gICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGgoXCJkaXZcIiwgeyBzdHlsZSwgLi4ub3RoZXJzIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IHsgSGVsbWV0IH0gZnJvbSBcIi4vaGVsbWV0XCI7XG5leHBvcnQgeyBJbWcgfSBmcm9tIFwiLi9pbWdcIjtcbmV4cG9ydCB7IExpbmsgfSBmcm9tIFwiLi9saW5rXCI7XG5leHBvcnQgeyBTdXNwZW5zZSB9IGZyb20gXCIuL3N1c3BlbnNlXCI7XG5leHBvcnQgeyBWaXNpYmxlIH0gZnJvbSBcIi4vdmlzaWJsZVwiO1xuZXhwb3J0IHsgUm91dGUsIFN3aXRjaCwgTGluayBhcyBWaWRhTGluayB9IGZyb20gXCIuL3JvdXRlclwiO1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBGcmFnbWVudCwgaCB9IGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgeyBIZWxtZXQgfSBmcm9tIFwiLi9oZWxtZXRcIjtcblxuZXhwb3J0IGNsYXNzIExpbmsgZXh0ZW5kcyBDb21wb25lbnQge1xuICBtb3VudCgpIHtcbiAgICBjb25zdCB7IHByZWZldGNoLCBocmVmLCBkZWxheSwgYmFjayA9IGZhbHNlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGJhY2spIHtcbiAgICAgIHRoaXMuZWxlbWVudHNbMF0uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICBmdW5jdGlvbiBvbkNsaWNrKHRoaXM6IExpbmssIGU6IEV2ZW50KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxMaW5rRWxlbWVudDtcbiAgICAgICAgICBpZiAodGFyZ2V0LmhyZWYgPT09IGRvY3VtZW50LnJlZmVycmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICB0aGlzLmVsZW1lbnRzWzBdLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgZnVuY3Rpb24gb25DbGljayh0aGlzOiBMaW5rLCBlOiBFdmVudCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHByZWZldGNoKSB7XG4gICAgICBpZiAocHJlZmV0Y2ggPT09IFwiaG92ZXJcIikge1xuICAgICAgICB0aGlzLnByZWZldGNoT25Ib3ZlcigpO1xuICAgICAgfSBlbHNlIGlmIChwcmVmZXRjaCA9PT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgdGhpcy5wcmVmZXRjaE9uVmlzaWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRQcmVmZXRjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByZWZldGNoT25Ib3ZlcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzWzBdLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcIm1vdXNlb3ZlclwiLFxuICAgICAgZnVuY3Rpb24gb25Ib3Zlcih0aGlzOiBMaW5rKSB7XG4gICAgICAgIHRoaXMuYWRkUHJlZmV0Y2goKTtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICk7XG4gIH1cblxuICBwcmVmZXRjaE9uVmlzaWJsZSgpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgIChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUHJlZmV0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHRocmVzaG9sZDogWzAsIDFdIH0sXG4gICAgKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudHNbMF0pO1xuICB9XG5cbiAgYWRkUHJlZmV0Y2goKSB7XG4gICAgbGV0IGV4aXN0cyA9IGZhbHNlO1xuXG4gICAgY29uc3QgbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIik7XG5cbiAgICBmb3IgKGNvbnN0IGxpbmsgb2YgbGlua3MpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGluay5nZXRBdHRyaWJ1dGUoXCJyZWxcIikgPT09IFwicHJlZmV0Y2hcIiAmJlxuICAgICAgICBsaW5rLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IHRoaXMucHJvcHMuaHJlZlxuICAgICAgKSB7XG4gICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFleGlzdHMpIHtcbiAgICAgIGNvbnN0IHByZWZldGNoID0gaChcImxpbmtcIiwge1xuICAgICAgICByZWw6IFwicHJlZmV0Y2hcIixcbiAgICAgICAgaHJlZjogdGhpcy5wcm9wcy5ocmVmLFxuICAgICAgICBhczogXCJkb2N1bWVudFwiLFxuICAgICAgfSk7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHByZWZldGNoKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBwcmVmZXRjaCxcbiAgICAgIGRlbGF5LFxuICAgICAgYmFjayA9IGZhbHNlLFxuICAgICAgcmVmLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgYSA9IGgoXCJhXCIsIHsgLi4ucmVzdCB9LCAuLi5jaGlsZHJlbik7XG5cbiAgICBpZiAocHJlZmV0Y2ggJiYgaXNTU1IpIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBoKFwibGlua1wiLCB7XG4gICAgICAgIHJlbDogXCJwcmVmZXRjaFwiLFxuICAgICAgICBocmVmOiB0aGlzLnByb3BzLmhyZWYsXG4gICAgICAgIGFzOiBcImRvY3VtZW50XCIsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGhlbG1ldCA9IGgoSGVsbWV0LCBudWxsLCBsaW5rKTtcbiAgICAgIHJldHVybiBoKEZyYWdtZW50LCBudWxsLCBbaGVsbWV0LCBhXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgaCwgcmVuZGVyRWxlbWVudCwgQ29tcG9uZW50IH0gZnJvbSBcIi4uL2NvcmVcIjtcblxuY29uc3QgaW5zdGFuY2VzOiBhbnlbXSA9IFtdO1xuXG5mdW5jdGlvbiByZWdpc3Rlcihjb21wOiBhbnkpIHtcbiAgaW5zdGFuY2VzLnB1c2goY29tcCk7XG59XG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXIoY29tcDogYW55KSB7XG4gIGluc3RhbmNlcy5zcGxpY2UoaW5zdGFuY2VzLmluZGV4T2YoY29tcCksIDEpO1xufVxuXG5mdW5jdGlvbiBoaXN0b3J5UHVzaChwYXRoOiBzdHJpbmcpIHtcbiAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCBcIlwiLCBwYXRoKTtcbiAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhpc3RvcnlSZXBsYWNlKHBhdGg6IHN0cmluZykge1xuICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIFwiXCIsIHBhdGgpO1xuICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hQYXRoKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBvcHRpb25zOiB7XG4gICAgZXhhY3Q/OiBib29sZWFuO1xuICAgIHBhdGg6IHN0cmluZztcbiAgICByZWdleD86IHsgW3BhcmFtOiBzdHJpbmddOiBSZWdFeHAgfTtcbiAgfSxcbikge1xuICBjb25zdCB7IGV4YWN0ID0gZmFsc2UsIHJlZ2V4IH0gPSBvcHRpb25zO1xuICBsZXQgeyBwYXRoIH0gPSBvcHRpb25zO1xuXG4gIGlmICghcGF0aCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgdXJsOiBwYXRobmFtZSxcbiAgICAgIGlzRXhhY3Q6IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIGxldCBtYXRjaDtcbiAgbGV0IHBhcmFtcyA9IHt9O1xuXG4gIC8vIHBhdGggd2l0aCBwYXJhbXNcbiAgaWYgKHBhdGguaW5jbHVkZXMoXCIvOlwiKSkge1xuICAgIGNvbnN0IHBhdGhBcnIgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBwYXRobmFtZUFyciA9IHBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICBwYXRoQXJyLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgIGlmICgvXjovLnRlc3QocCkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcC5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRobmFtZUFycltpXTtcblxuICAgICAgICAvLyBpZiBhIHJlZ2V4IGlzIHByb3ZpZGVkLCBjaGVjayBpdCBpdCBtYXRjaGVzXG4gICAgICAgIGlmIChyZWdleCAmJiByZWdleFtrZXldKSB7XG4gICAgICAgICAgY29uc3QgcmVnZXhNYXRjaCA9IHJlZ2V4W2tleV0udGVzdCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFyZWdleE1hdGNoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtcyA9IHsgLi4ucGFyYW1zLCBba2V5XTogdmFsdWUgfTtcblxuICAgICAgICBwYXRoQXJyW2ldID0gcGF0aG5hbWVBcnJbaV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGF0aCA9IHBhdGhBcnIuam9pbihcIi9cIik7XG4gIH1cblxuICAvLyBjYXRjaCBhbGxcbiAgaWYgKHBhdGggPT09IFwiKlwiKSBtYXRjaCA9IFtwYXRobmFtZV07XG5cbiAgLy8gcmVndWxhciBwYXRoXG4gIGlmICghbWF0Y2gpIG1hdGNoID0gbmV3IFJlZ0V4cChgXiR7cGF0aH1gKS5leGVjKHBhdGhuYW1lKTtcblxuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCB1cmwgPSBtYXRjaFswXTtcbiAgY29uc3QgaXNFeGFjdCA9IHBhdGhuYW1lID09PSB1cmw7XG5cbiAgaWYgKGV4YWN0ICYmICFpc0V4YWN0KSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgdXJsLFxuICAgIGlzRXhhY3QsXG4gICAgcGFyYW1zLFxuICB9O1xufVxuXG5leHBvcnQgY2xhc3MgU3dpdGNoIGV4dGVuZHMgQ29tcG9uZW50PHsgZmFsbGJhY2s/OiBhbnk7IGNoaWxkcmVuPzogYW55IH0+IHtcbiAgaW5kZXg6IG51bWJlciA9IDA7XG4gIHBhdGg6IHN0cmluZyA9IFwiXCI7XG4gIG1hdGNoID0geyBpbmRleDogLTEsIHBhdGg6IFwiXCIgfTtcblxuICBtb3VudCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMuZm9yY2VVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgcmVnaXN0ZXIodGhpcyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHVucmVnaXN0ZXIodGhpcyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLmZvcmNlVXBkYXRlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgZm9yY2VVcGRhdGUoKSB7XG4gICAgdGhpcy5maW5kQ2hpbGQoKTtcbiAgICBpZiAodGhpcy5zaG91bGRVcGRhdGUoKSkgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGZpbmRDaGlsZCgpIHtcbiAgICB0aGlzLm1hdGNoID0geyBpbmRleDogLTEsIHBhdGg6IFwiXCIgfTtcblxuICAgIGZvciAoY29uc3QgW2ksIGNoaWxkXSBvZiB0aGlzLnByb3BzLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgeyBwYXRoLCBleGFjdCwgcmVnZXggfSA9IGNoaWxkLnByb3BzO1xuICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICAgIHR5cGVvZiBpc1NTUiAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgID8gX25hbm8ubG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgICA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgZXhhY3QsXG4gICAgICAgICAgcmVnZXgsXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHRoaXMubWF0Y2guaW5kZXggPSBpO1xuICAgICAgICB0aGlzLm1hdGNoLnBhdGggPSBwYXRoO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2hvdWxkVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGggIT09IHRoaXMubWF0Y2gucGF0aCB8fCB0aGlzLmluZGV4ICE9PSB0aGlzLm1hdGNoLmluZGV4O1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuZmluZENoaWxkKCk7XG5cbiAgICBjb25zdCBjaGlsZCA9IHRoaXMucHJvcHMuY2hpbGRyZW5bdGhpcy5tYXRjaC5pbmRleF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHsgcGF0aCB9ID0gY2hpbGQucHJvcHM7XG4gICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgdGhpcy5pbmRleCA9IHRoaXMubWF0Y2guaW5kZXg7XG4gICAgICBjb25zdCBlbCA9IHJlbmRlckVsZW1lbnQoY2hpbGQpO1xuICAgICAgcmV0dXJuIHJlbmRlckVsZW1lbnQoZWwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5mYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHJlbmRlckVsZW1lbnQodGhpcy5wcm9wcy5mYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoKFwiZGl2XCIsIHsgY2xhc3M6IFwicm91dGVcIiB9LCBcIm5vdCBmb3VuZFwiKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlKHtcbiAgcGF0aCxcbiAgcmVnZXgsXG4gIGNoaWxkcmVuLFxufToge1xuICBleGFjdD86IGJvb2xlYW47XG4gIHBhdGg6IHN0cmluZztcbiAgcmVnZXg/OiB7IFtwYXJhbTogc3RyaW5nXTogUmVnRXhwIH07XG4gIGNoaWxkcmVuPzogYW55O1xufSkge1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkLnByb3BzKSBjaGlsZC5wcm9wcyA9IHsgLi4uY2hpbGQucHJvcHMsIHJvdXRlOiB7IHBhdGgsIHJlZ2V4IH0gfTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZXhwb3J0IGNvbnN0IHRvID0gKHRvOiBzdHJpbmcsIHJlcGxhY2U6IGJvb2xlYW4gPSBmYWxzZSkgPT4ge1xuICByZXBsYWNlID8gaGlzdG9yeVJlcGxhY2UodG8pIDogaGlzdG9yeVB1c2godG8pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIExpbmsoe1xuICB0byxcbiAgcmVwbGFjZSxcbiAgY2hpbGRyZW4sXG59OiB7XG4gIHRvOiBzdHJpbmc7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IGFueTtcbn0pIHtcbiAgZnVuY3Rpb24gb25DbGljayhldmVudDogRXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJlcGxhY2UgPyBoaXN0b3J5UmVwbGFjZSh0bykgOiBoaXN0b3J5UHVzaCh0byk7XG4gIH1cblxuICByZXR1cm4gaChcImFcIiwgeyBocmVmOiB0bywgb25DbGljayB9LCBjaGlsZHJlbik7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgc3RyVG9IYXNoIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmV4cG9ydCBjbGFzcyBTdXNwZW5zZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHByaXZhdGUgaXNSZWFkeSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBhbnkpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICBjb25zdCB7IGZhbGxiYWNrLCBjYWNoZSA9IGZhbHNlLCBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuaWQgPSBzdHJUb0hhc2goXG4gICAgICBKU09OLnN0cmluZ2lmeShyZXN0LCBmdW5jdGlvbiAoX2tleSwgdmFsKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyBgJHt2YWx9YCA6IHZhbDtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBhc3luYyBtb3VudCgpIHtcbiAgICBjb25zdCB7IGZhbGxiYWNrLCBjYWNoZSA9IGZhbHNlLCBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChjYWNoZSkgdGhpcy5pbml0aWFsU3RhdGUgPSB7fTtcblxuICAgIGlmICh0aGlzLmxvYWRGcm9tQ2FjaGUoY2FjaGUpKSByZXR1cm47XG5cbiAgICBjb25zdCBwcm9taXNlcyA9IE9iamVjdC52YWx1ZXMocmVzdCkubWFwKChwOiBhbnkpID0+IHAoKSk7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucHJlcGFyZURhdGEocmVzdCwgcmVzb2x2ZWQsIGNhY2hlKTtcblxuICAgIHRoaXMuYWRkRGF0YVRvQ2hpbGRyZW4oZGF0YSk7XG5cbiAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBwcml2YXRlIGxvYWRGcm9tQ2FjaGUoY2FjaGU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLnN0YXRlICYmIGNhY2hlICYmIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUpLmxlbmd0aDtcblxuICAgIGlmIChjYWNoZSkge1xuICAgICAgdGhpcy5hZGREYXRhVG9DaGlsZHJlbih0aGlzLnN0YXRlKTtcbiAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuXG4gIHByaXZhdGUgc3NyKCkge1xuICAgIGNvbnN0IHsgZmFsbGJhY2ssIGNhY2hlID0gZmFsc2UsIGNoaWxkcmVuLCAuLi5yZXN0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgZnVuY3MgPSBPYmplY3QudmFsdWVzKHJlc3QpLm1hcCgocDogYW55KSA9PiBwKCkpO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMucHJlcGFyZURhdGEocmVzdCwgZnVuY3MsIGZhbHNlKTtcblxuICAgIHRoaXMuYWRkRGF0YVRvQ2hpbGRyZW4oZGF0YSk7XG4gIH1cblxuICBwcml2YXRlIGFkZERhdGFUb0NoaWxkcmVuKGRhdGE6IGFueSkge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkLnByb3BzKSB7XG4gICAgICAgIGNoaWxkLnByb3BzID0geyAuLi5jaGlsZC5wcm9wcywgLi4uZGF0YSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJlcGFyZURhdGEocmVzdDogYW55LCBmdW5jOiBhbnksIGNhY2hlOiBib29sZWFuKSB7XG4gICAgY29uc3QgZGF0YSA9IE9iamVjdC5rZXlzKHJlc3QpLnJlZHVjZSgoYWNjLCBpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IC4uLnRoaXMuc3RhdGUsIFtpdGVtXTogZnVuY1tpbmRleF0gfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2l0ZW1dOiBmdW5jW2luZGV4XSxcbiAgICAgIH07XG4gICAgfSwge30pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0eXBlb2YgaXNTU1IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnN0IHsgY2FjaGUgPSBmYWxzZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHRoaXMubG9hZEZyb21DYWNoZShjYWNoZSk7XG4gICAgICByZXR1cm4gdGhpcy5pc1JlYWR5ID8gdGhpcy5wcm9wcy5jaGlsZHJlbiA6IHRoaXMucHJvcHMuZmFsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3NyKCk7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgaCwgcmVuZGVyIH0gZnJvbSBcIi4uL2NvcmVcIjtcblxuZXhwb3J0IGNsYXNzIFZpc2libGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwcml2YXRlIGlzVmlzaWJsZSA9IGZhbHNlO1xuXG4gIG1vdW50KCkge1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgICAgKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHRocmVzaG9sZDogWzAsIDFdIH0sXG4gICAgKTtcblxuICAgIG9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50c1swXSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub25WaXNpYmxlKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25WaXNpYmxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVuZGVyKHRoaXMucHJvcHMuY29tcG9uZW50IHx8IHRoaXMucHJvcHMuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaChcImRpdlwiLCB7IFwiZGF0YS12aXNpYmxlXCI6IGZhbHNlLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgcmVuZGVyRWxlbWVudCB9IGZyb20gXCIuXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZHJlbihlbGVtZW50OiBIVE1MRWxlbWVudCwgY2hpbGRyZW46IGFueSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgYXBwZW5kQ2hpbGRyZW4oZWxlbWVudCwgW2NoaWxkcmVuXSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICBjaGlsZHJlbiA9IEFycmF5LmZyb20oY2hpbGRyZW4pO1xuICB9XG5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgYXBwZW5kQ2hpbGRyZW4oZWxlbWVudCwgY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29tcCA9IHJlbmRlckVsZW1lbnQoY2hpbGQpIGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICBpZiAoY29tcCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wKSkge1xuICAgICAgICAgIGFwcGVuZENoaWxkcmVuKGVsZW1lbnQsIGNvbXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAhY29tcD8ubm9kZVR5cGUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiICsgY29tcCkgOiBjb21wLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IG5leHRUaWNrLCBvbk5vZGVSZW1vdmUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCB7IHJlbmRlckVsZW1lbnQsIF9zdGF0ZSB9IGZyb20gXCIuXCI7XG5cbmV4cG9ydCBjbGFzcyBDb21wb25lbnQ8UCBleHRlbmRzIE9iamVjdCA9IGFueSwgUyA9IGFueT4ge1xuICBwdWJsaWMgaWQ6IHN0cmluZyB8IG51bWJlcjtcbiAgcHJpdmF0ZSBfc2tpcFVubW91dDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBfaGFzVW5tb3VudGVkOiBib29sZWFuO1xuICBwcml2YXRlIF9lbGVtZW50czogSFRNTEVsZW1lbnRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwcm9wczogUCkge1xuICAgIHRoaXMuaWQgPSB0aGlzLl9nZXRIYXNoKCk7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKF91cGRhdGU/OiBhbnkpIHt9XG4gIHB1YmxpYyBtb3VudCgpIHt9XG4gIHB1YmxpYyBiZWZvcmVNb3VudCgpIHt9XG4gIHB1YmxpYyBkZXN0cm95KCkge31cbiAgcHJpdmF0ZSBfZ2V0SGFzaCgpOiBhbnkge31cblxuICBzZXRTdGF0ZShzdGF0ZTogUywgc2hvdWxkVXBkYXRlOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICBpZiAoc3RhdGUgJiYgdHlwZW9mIHN0YXRlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLnN0YXRlID0geyAuLi50aGlzLnN0YXRlLCAuLi5zdGF0ZSB9O1xuICAgIH0gZWxzZSB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiBfc3RhdGUuZ2V0KHRoaXMuaWQpO1xuICB9XG5cbiAgc2V0IHN0YXRlKHZhbHVlOiBTKSB7XG4gICAgX3N0YXRlLnNldCh0aGlzLmlkLCB2YWx1ZSk7XG4gIH1cblxuICBzZXQgaW5pdGlhbFN0YXRlKHN0YXRlOiBTKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlKSB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50cztcbiAgfVxuXG4gIHB1YmxpYyBzZXQgZWxlbWVudHMoZWxlbWVudHM6IEhUTUxFbGVtZW50W10pIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBlbCBvZiBlbGVtZW50cykge1xuICAgICAgdGhpcy5fZWxlbWVudHMucHVzaChlbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhZGROb2RlUmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgaWYgKC9eW157XSt7XFxzK30kL2dtLnRlc3QodGhpcy5kZXN0cm95LnRvU3RyaW5nKCkpKSByZXR1cm47XG5cbiAgICBvbk5vZGVSZW1vdmUodGhpcy5lbGVtZW50c1swXSwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9za2lwVW5tb3V0KSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy9AdHMtaWdub3JlXG4gIHByaXZhdGUgX21vdW50KCkge1xuICAgIHRoaXMuYWRkTm9kZVJlbW92ZUxpc3RlbmVyKCk7XG4gICAgdGhpcy5tb3VudCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGVzdG9yeSgpIHtcbiAgICBpZiAodGhpcy5faGFzVW5tb3VudGVkKSByZXR1cm47XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5faGFzVW5tb3VudGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUodXBkYXRlPzogYW55KSB7XG4gICAgdGhpcy5fc2tpcFVubW91dCA9IHRydWU7XG5cbiAgICBjb25zdCBvbGRFbGVtZW50cyA9IFsuLi50aGlzLmVsZW1lbnRzXTtcblxuICAgIHRoaXMuX2VsZW1lbnRzID0gW107XG5cbiAgICBsZXQgZWwgPSB0aGlzLnJlbmRlcih1cGRhdGUpO1xuICAgIGVsID0gcmVuZGVyRWxlbWVudChlbCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IChlbCBhcyB1bmtub3duKSBhcyBIVE1MRWxlbWVudFtdO1xuXG4gICAgY29uc3QgcGFyZW50ID0gb2xkRWxlbWVudHNbMF0ucGFyZW50RWxlbWVudCBhcyBIVE1MRWxlbWVudDtcblxuICAgIGlmICghcGFyZW50KVxuICAgICAgY29uc29sZS53YXJuKFwiQ29tcG9uZW50IG5lZWRzIGEgcGFyZW50IGVsZW1lbnQgdG8gZ2V0IHVwZGF0ZWQhXCIpO1xuXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBvbGRFbGVtZW50c1swXSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgY2hpbGQgb2Ygb2xkRWxlbWVudHMpIHtcbiAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgLy9AdHMtaWdub3JlXG4gICAgICBjaGlsZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5hZGROb2RlUmVtb3ZlTGlzdGVuZXIoKTtcblxuICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRoaXMuX3NraXBVbm1vdXQgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1swXS5pc0Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9kZXN0b3J5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGN0eDogYW55KSB7XG4gIGxldCBfY3R4ID0gY3R4O1xuICByZXR1cm4ge1xuICAgIFByb3ZpZGVyKHByb3BzOiBhbnkpIHtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSkge1xuICAgICAgICBfY3R4ID0gcHJvcHMudmFsdWU7XG4gICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9LFxuICAgIENvbnN1bWVyKHByb3BzOiBhbnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudDogcHJvcHMuY2hpbGRyZW5bMF0oX2N0eCksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgY29udGV4dDogX2N0eCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gX2N0eDtcbiAgICB9LFxuICAgIHNldChjdHg6IGFueSkge1xuICAgICAgX2N0eCA9IGN0eDtcbiAgICB9LFxuICB9O1xufVxuIiwiZXhwb3J0IGNvbnN0IEZyYWdtZW50ID0gKHByb3BzOiBhbnkpID0+IHtcbiAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcbiIsImltcG9ydCB7IGlzRXZlbnQgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCB7IGFwcGVuZENoaWxkcmVuLCBoTlMgfSBmcm9tIFwiLlwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaChjb21wOiBhbnksIHByb3BzOiBhbnksIC4uLmNoaWxkcmVuOiBhbnlbXSk6IGFueSB7XG4gIGlmICh0eXBlb2YgY29tcCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7IGNvbXBvbmVudDogY29tcCwgcHJvcHM6IHsgLi4ucHJvcHMsIGNoaWxkcmVuOiBjaGlsZHJlbiB9IH07XG4gIH1cblxuICBsZXQgcmVmO1xuXG4gIGNvbnN0IGVsZW1lbnQgPVxuICAgIGNvbXAgPT09IFwic3ZnXCJcbiAgICAgID8gKGhOUyhcInN2Z1wiKSBhcyBTVkdFbGVtZW50KVxuICAgICAgOiAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjb21wKSBhcyBIVE1MRWxlbWVudCk7XG5cbiAgZm9yIChjb25zdCBwIGluIHByb3BzKSB7XG4gICAgaWYgKHAgPT09IFwic3R5bGVcIiAmJiB0eXBlb2YgcHJvcHNbcF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IE9iamVjdC5rZXlzKHByb3BzW3BdKVxuICAgICAgICAubWFwKChrKSA9PiBgJHtrfToke3Byb3BzW3BdW2tdfWApXG4gICAgICAgIC5qb2luKFwiO1wiKVxuICAgICAgICAucmVwbGFjZSgvW0EtWl0vZywgKG1hdGNoKSA9PiBgLSR7bWF0Y2gudG9Mb3dlckNhc2UoKX1gKTtcbiAgICAgIHByb3BzW3BdID0gc3R5bGVzICsgXCI7XCI7XG4gICAgfVxuXG4gICAgaWYgKHAgPT09IFwicmVmXCIpIHtcbiAgICAgIHJlZiA9IHByb3BzW3BdO1xuICAgIH1cblxuICAgIGlmIChpc0V2ZW50KGVsZW1lbnQsIHAudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihwLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDIpLCAoZTogRXZlbnQpID0+XG4gICAgICAgIHByb3BzW3BdKGUpLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocCwgcHJvcHNbcF0pO1xuICAgIH1cbiAgfVxuICBhcHBlbmRDaGlsZHJlbihlbGVtZW50IGFzIGFueSwgY2hpbGRyZW4pO1xuXG4gIGlmIChyZWYpIHtcbiAgICByZWYoZWxlbWVudCk7XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoZWxlbWVudC5zc3IpIHJldHVybiBlbGVtZW50LnNzcjtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4iLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLlwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZShcbiAgY29tcG9uZW50OiBhbnksXG4gIHBhcmVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbCxcbiAgcmVtb3ZlQ2hpbGROb2RlcyA9IHRydWUsXG4pIHtcbiAgcmV0dXJuIHJlbmRlcihjb21wb25lbnQsIHBhcmVudCwgcmVtb3ZlQ2hpbGROb2Rlcyk7XG59XG4iLCJleHBvcnQgeyBhcHBlbmRDaGlsZHJlbiB9IGZyb20gXCIuL2FwcGVuZENoaWxkcmVuXCI7XG5leHBvcnQgeyBoIH0gZnJvbSBcIi4vaFwiO1xuZXhwb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vcmVuZGVyXCI7XG5leHBvcnQgeyByZW5kZXJFbGVtZW50LCBoTlMgfSBmcm9tIFwiLi9yZW5kZXJFbGVtZW50XCI7XG5leHBvcnQgeyBoeWRyYXRlIH0gZnJvbSBcIi4vaHlkcmF0ZVwiO1xuZXhwb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4vY29tcG9uZW50XCI7XG5leHBvcnQgeyBGcmFnbWVudCB9IGZyb20gXCIuL2ZyYWdtZW50XCI7XG5leHBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dFwiO1xuZXhwb3J0IHsgX3N0YXRlLCBfY2xlYXJTdGF0ZSB9IGZyb20gXCIuL3N0YXRlXCI7XG5leHBvcnQgeyBsYXp5SHlkcmF0aW9uIH0gZnJvbSBcIi4vbGF6eUh5ZHJhdGlvblwiO1xuZXhwb3J0IHsgd2l0aFN0eWxlcyB9IGZyb20gXCIuL3dpdGhTdHlsZXNcIjtcbiIsImltcG9ydCB7IFZpc2libGUgfSBmcm9tIFwiLi4vY29tcG9uZW50c1wiO1xuaW1wb3J0IHsgaCwgaHlkcmF0ZSB9IGZyb20gXCIuXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXp5SHlkcmF0aW9uKFxuICBjb21wb25lbnQ6IGFueSxcbiAgcGFyZW50OiBhbnksXG4gIHJlbW92ZUNoaWxkTm9kZXMgPSB0cnVlLFxuKSB7XG4gIGNvbnN0IGNtcCA9IGgoVmlzaWJsZSwgbnVsbCwgY29tcG9uZW50KTtcbiAgcmV0dXJuIGh5ZHJhdGUoY21wLCBwYXJlbnQsIHJlbW92ZUNoaWxkTm9kZXMpO1xufVxuIiwiaW1wb3J0IHsgYXBwZW5kQ2hpbGRyZW4sIHJlbmRlckVsZW1lbnQgfSBmcm9tIFwiLlwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKFxuICBjbXA6IGFueSxcbiAgcGFyZW50OiBIVE1MRWxlbWVudCB8IGFueSA9IG51bGwsXG4gIHJlbW92ZUNoaWxkTm9kZXMgPSB0cnVlLFxuKSB7XG4gIGxldCBlbCA9IHJlbmRlckVsZW1lbnQoY21wKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICBlbCA9IGVsLm1hcCgoYykgPT4gcmVuZGVyRWxlbWVudChjKSk7XG4gICAgaWYgKGVsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZWwgPSBlbFswXTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyZW50KSB7XG4gICAgaWYgKHJlbW92ZUNoaWxkTm9kZXMpIHtcbiAgICAgIHJlbW92ZUFsbENoaWxkTm9kZXMocGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZWwgJiYgcGFyZW50LmlkICYmIHBhcmVudC5pZCA9PT0gZWwuaWQgJiYgcGFyZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHBhcmVudC5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZChlbCwgcGFyZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgICAgIGVsLm1hcCgoYykgPT4gYXBwZW5kQ2hpbGRyZW4ocGFyZW50LCByZW5kZXJFbGVtZW50KGMpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmRDaGlsZHJlbihwYXJlbnQsIHJlbmRlckVsZW1lbnQoZWwpKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuc3NyKSByZXR1cm4gcGFyZW50LnNzcjtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgaXNTU1IgPT09IFwiYm9vbGVhblwiICYmIGlzU1NSICYmICFBcnJheS5pc0FycmF5KGVsKSkgcmV0dXJuIFtlbF07XG4gICAgcmV0dXJuIGVsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGxDaGlsZE5vZGVzKGVsOiBIVE1MRWxlbWVudCkge1xuICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBuZXh0VGljaywgc3RyVG9IYXNoIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJFbGVtZW50KGNtcDogYW55KTogYW55IHtcbiAgaWYgKFtcInVuZGVmaW5lZFwiIHx8IFwib2JqZWN0XCJdLmluY2x1ZGVzKHR5cGVvZiBjbXApKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChjbXAgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY21wID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY21wID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIFwiXCIgKyBjbXA7XG4gIH1cblxuICBpZiAoY21wPy50YWdOYW1lICYmIGNtcC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIpIHtcbiAgICByZXR1cm4gU1ZHKHsgY2hpbGRyZW46IFtjbXBdIH0pO1xuICB9XG5cbiAgaWYgKGNtcD8udGFnTmFtZSkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBpZiAoXG4gICAgY21wICYmXG4gICAgY21wLmNvbXBvbmVudCAmJlxuICAgIGNtcC5jb21wb25lbnQucHJvdG90eXBlICYmXG4gICAgY21wLmNvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgJiZcbiAgICAvXmNsYXNzXFxzLy50ZXN0KEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNtcC5jb21wb25lbnQpKVxuICApIHtcbiAgICByZXR1cm4gcmVuZGVyQ2xhc3NDb21wb25lbnQoY21wKTtcbiAgfVxuXG4gIGlmIChjbXAuY29tcG9uZW50ICYmIHR5cGVvZiBjbXAuY29tcG9uZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gcmVuZGVyRnVuY3Rpb25hbENvbXBvbmVudChjbXApO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY21wKSkge1xuICAgIHJldHVybiBjbXAubWFwKChjKSA9PiByZW5kZXJFbGVtZW50KGMpKS5mbGF0KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNtcCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gcmVuZGVyRWxlbWVudChjbXAoKSk7XG5cbiAgaWYgKGNtcD8uY29tcG9uZW50Py50YWdOYW1lICYmIHR5cGVvZiBjbXAuY29tcG9uZW50LnRhZ05hbWUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHJlbmRlckVsZW1lbnQoY21wLmNvbXBvbmVudCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY21wLmNvbXBvbmVudCkpIHJldHVybiByZW5kZXJFbGVtZW50KGNtcC5jb21wb25lbnQpO1xuXG4gIGlmIChjbXAuY29tcG9uZW50KSByZXR1cm4gcmVuZGVyRWxlbWVudChjbXAuY29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRnVuY3Rpb25hbENvbXBvbmVudChjbXA6IGFueSkge1xuICBjb25zdCB7IGNvbXBvbmVudCwgcHJvcHMgfSA9IGNtcDtcbiAgY29uc3QgZWwgPSBjb21wb25lbnQocHJvcHMpO1xuICByZXR1cm4gcmVuZGVyRWxlbWVudChlbCk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzQ29tcG9uZW50KGNtcDogYW55KSB7XG4gIGNvbnN0IHsgY29tcG9uZW50LCBwcm9wcyB9ID0gY21wO1xuXG4gIGNvbnN0IGhhc2ggPSBzdHJUb0hhc2goY29tcG9uZW50LnRvU3RyaW5nKCkpO1xuXG4gIGNvbXBvbmVudC5wcm90b3R5cGUuX2dldEhhc2ggPSAoKSA9PiBoYXNoO1xuXG4gIGNvbnN0IENvbXBvbmVudCA9IG5ldyBjb21wb25lbnQocHJvcHMpO1xuXG4gIENvbXBvbmVudC5iZWZvcmVNb3VudCgpO1xuXG4gIGxldCBlbCA9IENvbXBvbmVudC5yZW5kZXIoKTtcbiAgZWwgPSByZW5kZXJFbGVtZW50KGVsKTtcblxuICBDb21wb25lbnQuZWxlbWVudHMgPSBlbDtcblxuICBpZiAocHJvcHM/LnJlZikgcHJvcHMucmVmKENvbXBvbmVudCk7XG4gIGlmICh0eXBlb2YgaXNTU1IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICBDb21wb25lbnQuX21vdW50KCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaE5TKHRhZzogc3RyaW5nKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG4gICAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHRhZyxcbiAgKSBhcyBTVkdFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBTVkcocHJvcHM6IGFueSkge1xuICBjb25zdCBjaGlsZCA9IHByb3BzLmNoaWxkcmVuWzBdIGFzIFNWR0VsZW1lbnQ7XG4gIGNvbnN0IGF0dHJzID0gY2hpbGQuYXR0cmlidXRlcztcblxuICBjb25zdCBzdmcgPSBoTlMoXCJzdmdcIikgYXMgU1ZHRWxlbWVudDtcblxuICBmb3IgKGNvbnN0IGF0dHIgb2YgYXR0cnMpIHtcbiAgICBzdmcuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gIH1cblxuICBzdmcuaW5uZXJIVE1MID0gY2hpbGQuaW5uZXJIVE1MO1xuXG4gIHJldHVybiBzdmc7XG59XG4iLCJleHBvcnQgY29uc3QgX3N0YXRlID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gX2NsZWFyU3RhdGUoKSB7XG4gIF9zdGF0ZS5jbGVhcigpO1xufVxuIiwiaW1wb3J0IHsgSGVsbWV0IH0gZnJvbSBcIi4uL2NvbXBvbmVudHNcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgaCwgRnJhZ21lbnQgfSBmcm9tIFwiLlwiO1xuXG5leHBvcnQgZnVuY3Rpb24gd2l0aFN0eWxlcyhzdHlsZXM6IGFueSk6IGFueSB7XG4gIHJldHVybiBmdW5jdGlvbiAoV3JhcHBlZENvbXBvbmVudDogYW55KSB7XG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBjb25zdCBoZWxtZXQgPSBoKEhlbG1ldCwgbnVsbCwgaChcInN0eWxlXCIsIG51bGwsIHN0eWxlcy50b1N0cmluZygpKSk7XG5cbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICAgPyBoKFdyYXBwZWRDb21wb25lbnQsIHsgLi4ucmVzdCB9LCBjaGlsZHJlbilcbiAgICAgICAgICA6IGgoV3JhcHBlZENvbXBvbmVudCwgeyAuLi50aGlzLnByb3BzIH0pO1xuXG4gICAgICAgIHJldHVybiBoKEZyYWdtZW50LCBudWxsLCBoZWxtZXQsIGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbiIsImV4cG9ydCBjb25zdCBuZXh0VGljayA9XG4gIHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCJcbiAgICA/IFByb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSlcbiAgICA6IHNldFRpbWVvdXQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0V2ZW50KGVsOiBhbnksIHByb3A6IHN0cmluZykge1xuICBpZiAoIX5wcm9wLmluZGV4T2YoXCJvblwiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZWwuc3NyKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIFtcImZ1bmN0aW9uXCIsIFwib2JqZWN0XCJdLmluY2x1ZGVzKHR5cGVvZiBlbFtwcm9wXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RTU1IoKSB7XG4gIC8vQHRzLWlnbm9yZVxuICByZXR1cm4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0clRvSGFzaChzdHI6IHN0cmluZykge1xuICBsZXQgaGFzaCA9IDA7XG5cbiAgaWYgKCFzdHIubGVuZ3RoKSByZXR1cm4gaGFzaDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNoYXI7XG4gICAgaGFzaCB8PSAwO1xuICB9XG4gIHJldHVybiBNYXRoLmFicyhoYXNoKS50b1N0cmluZygzMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQoZGVzY2VuZGFudDogYW55LCByb290OiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBkZXNjZW5kYW50ICYmXG4gICAgKGRlc2NlbmRhbnQgPT09IHJvb3QgfHwgaXNEZXNjZW5kYW50KGRlc2NlbmRhbnQucGFyZW50Tm9kZSwgcm9vdCkpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbk5vZGVSZW1vdmUoZWw6IEhUTUxFbGVtZW50LCBjYWxsYmFjazogKCkgPT4gYW55KSB7XG4gIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRMaXN0KSA9PiB7XG4gICAgZm9yIChjb25zdCBtdXQgb2YgbXV0TGlzdCkge1xuICAgICAgbXV0LnJlbW92ZWROb2Rlcy5mb3JFYWNoKChyZW1vdmVkTm9kZSkgPT4ge1xuICAgICAgICBpZiAoaXNEZXNjZW5kYW50KGVsLCByZW1vdmVkTm9kZSkpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gIH0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YXNrKGZ1bmM6ICgpID0+IHZvaWQpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZnVuYywgMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2RlVG9TdHJpbmcobm9kZTogYW55KSB7XG4gIGNvbnN0IHRlbXAgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHRlbXAuYXBwZW5kQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICByZXR1cm4gdGVtcC50b1N0cmluZygpO1xufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsImltcG9ydCB7IGgsIHJlbmRlciB9IGZyb20gXCIuLi9jb3JlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaCxcbiAgcmVuZGVyLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=
